#!/usr/bin/perl
#
# Utility script to build customized gstreamer distributions given an xml definition
# of the distribution. The distribution is defined in a gstbuildpars.xml file by default
#
use strict;
use File::Copy "cp";
use File::Path;
use File::Basename;
use Getopt::Long;
use Cwd 'fast_abs_path';
use Cwd 'abs_path';
use XML::Simple;
use Data::Dumper;
use Switch;

my $scpath=dirname(abs_path($0));
require "$scpath/nlperl/nlperl_common.pl";

sub file_out {
    my ($fname, $contents) = @_;
    open ( FILE, ">$fname") or die "couldn't open $fname for writing";
    print FILE $contents;
    close (FILE);
}


my $dist_type = "linux";
my $GST_MAJOR_VERSION = "0";
my $GST_MINOR_VERSION = "10";
my $GST_VER_SUFFIX = "-" . $GST_MAJOR_VERSION . "." . $GST_MINOR_VERSION;
my $GST_LIB_PREFIX = "lib";
my %deploy_cache; # keeps track of libraries that have already beend deployed
my $LDD_WIN32; # ldd win32 command
my $STRIP_WIN32; # win32 strip cmd

sub bin_ext {
    my $ext ="";
    if( $dist_type eq "win32" ){
        $ext = ".exe";
    }
    return $ext;
}

sub library_ext {
    my $ext = "so";
    if( $dist_type eq "win32" ){ $ext = "dll"; }
    if( $dist_type eq "linux" ){ $ext = "so"; }
    return $ext;
}

sub lddcmd {
    my ($args) = @_;
    my $res;

    if( $dist_type eq "win32" ){
        $res = "$LDD_WIN32 $args";
    } else {
        $res = "ldd $args";
    }
    
    return $res;
}

sub strip {
    my ($file) = @_;
    my $cmd = "strip $file";
    if( $dist_type eq "win32" ){
        $cmd = "$STRIP_WIN32 $file";
    }

    if( $dist_type eq "linux" ){
        $cmd = "strip $file";
    }
    __system ($cmd);    
}

sub bin_name {
    my ($name) = @_;
    return "$name" . bin_ext();
}

sub library_name {
    my ($name) = @_;
    return "lib" . $name . "." . library_ext();
}


sub gname {
    my ($name) = @_;
    return "lib" . $name . "-2.0-0.dll";
}
sub lname {
    my ($name) = @_;
    return $GST_LIB_PREFIX . $name . $GST_VER_SUFFIX . ".dll";
}

sub pname {
    my ($name) = @_;
    return library_name( "gst" . $name );
}


# items to copy


sub deploy_group
{
    my ($groupname, $xml, $dirs) = @_;
    #get item array
    die "$groupname not found in xml file\n" if not exists $xml->{group}->{$groupname};

    my @items = @{$xml->{group}->{$groupname}->{item}};

    #item is a hash table defined as 
    #   { 
    #   'dest'    => destdir
    #   'content' => item_name
    #   'type'    => item_type
    #   }
    
    for my $item (@items) {
        switch($item->{type}) {
            my $name = $item->{content};
            case 'group' { deploy_group( $item->{content}, $xml, $dirs ); }

            my $dstdir = $dirs->{dstdirs}->{ $item->{dest} };
            
            case 'pname' { deploy_file( $dirs, $dstdir, pname($name) ); }
            case 'gname' { deploy_file( $dirs, $dstdir, gname($name) ); }
            case 'plain' { deploy_file( $dirs, $dstdir,       $name  ); }
            case 'bin'   { deploy_file( $dirs, $dstdir,bin_name($name) ); }
            case 'lname' { deploy_file( $dirs, $dstdir, lname($name) ); }
        }
    }
}

#finds file in src dirs and returns full path to the file 
#returns '' otherwise
sub find_file_dir {
    my ($name, $srcdirs) = @_;

    for my $srcdir (@{$srcdirs}) {
        my $path = $srcdir . $name;
        #print "looking for $path\n";
        if( -e $path and not -d $path ) { return $srcdir; };
    }
    return '';
}

#returns array with dependencies. empty array if no intrinsic deps
# the return array is a hash with the dep and a suggested dst location 
sub find_deps {
    my ($dirs, $filename) = @_;
    my $srcdirs = $dirs->{srcdirs};
    my $dstdirs = $dirs->{dstdirs};

    my $ofile = find_file_dir($filename,$srcdirs) . $filename;

    #run ldd and retrieve first level deps
    my $cmd = lddcmd($ofile);
    my @deps =  `$cmd`;
    my %outdeps;

    foreach my $line (@deps) {
        my ($dep) = $line =~ /(\S+) =>/s ;
        if( find_file_dir($dep, $srcdirs) ne '' ) {
            if( $dist_type eq "win32" ) {
                $outdeps{$dep} = $dstdirs->{bindir};
            } else {
                $outdeps{$dep} = $dstdirs->{libdir};
            }

            #print "dep: $dep\n";
        }
    }
    
    return %outdeps;

}


#deploys file with dependencies if necessary
sub deploy_file {
    my ($dirs, $dstdir, $filename ) = @_;
    my $srcdirs = $dirs->{srcdirs};
    my $dstdirs = $dirs->{dstdirs};

    if ( not defined($deploy_cache{$filename})) {
        my $srcdir = find_file_dir ($filename, $srcdirs);
        die "$filename could not be found in any of the source directories" if $srcdir eq '';

        # copy ourselves first
        copy_file( $srcdir, $dstdir, $filename );

        # find dependcies (in our sources) as file names (not full paths)
        my %deps = find_deps($dirs, $filename);
        # deploy dependencies (where?) bin/win32  lib/linux-darwin
        foreach my $dep (keys %deps) {
            deploy_file($dirs, $deps{$dep}, $dep);
        }

        $deploy_cache{$filename} = 1;
    }

}
sub copy_file {
    my ($src_dir, $dst_dir, $filename) = @_;

    die "invalid parameters for file copy: src=$src_dir dst=$dst_dir filename=$filename\n" if $src_dir eq "" or $dst_dir eq "" or $filename eq "";
    mkpath $dst_dir;
    my $src = $src_dir . $filename;
    my $dst = $dst_dir . $filename;

    print "$src => $dst\n";
    __system ("cp $src $dst") == 0 or die "couldn't copy file $src";
    strip($dst);

    #do relative path handling
    if( $dist_type eq "linux" ) {
        relativize_rpath($src, $dst);
    }
       
}

sub help {
    my $help = <<"HELP";
    usage: gst_build_dst --pars <pars_file> --src_base <src_base> --dst_base <dst_base>
HELP
    print $help;
}

sub check_prerequisites {
    if( $dist_type eq "win32" ) {
        die "wine doesn't seem to be installed. needed for ldd.exe" if not `which wine` =~ /wine/;

        $LDD_WIN32 = fast_abs_path("tools/ldd.exe");
        $LDD_WIN32 = "wine $LDD_WIN32 -w ";
        $STRIP_WIN32 = "i586-mingw32msvc-strip"; #FIXME totally fix this
        print "LDD_WIN32: $LDD_WIN32\n";
        print "STRIP_WIN32: $STRIP_WIN32\n";
    }
}

sub create_tar_dist {
    my ($xml, $distdir, $tardir) = @_;

    if( not exists $xml->{options}->{tardist}->[0] ) { return; };
    my $xtardist = $xml->{options}->{tardist}->[0]; 

    mkpath $tardir;
#tardist is now a hash like in
#                                        {
#                                      'tar' => 'on',
#                                      'content' => 'sample_dist',
#                                      'bgz' => 'on',
#                                      'sevenzip' => 'on',
#                                      'tgz' => 'on'
#                                    }

    my $tar = defined $xtardist->{tar} ? $xtardist->{tar} : '';
    my $sevenzip = defined $xtardist->{sevenzip} ? $xtardist->{sevenzip} : '';
    my $gzip = defined $xtardist->{gzip} ? $xtardist->{gzip} : '';
    my $bzip2 = defined $xtardist->{bzip2} ? $xtardist->{bzip2} : '';

    my $tarbase = $tardir."/".$xtardist->{content};

    if( $tar eq 'on' ) {
        __system ("tar cPf $tarbase.tar -C $distdir `ls $distdir`", 1) ;
    }

    if( $sevenzip eq 'on' ) {
        __system ("tar cPf $tarbase.tar -C $distdir `ls $distdir`", 1);
        __system ("7zr a -mx=9 $tarbase.tar.7z $tarbase.tar",1);
    }

    if( $gzip eq 'on' ) {
        __system ("tar czPf $tarbase.tar.gz -C $distdir `ls $distdir`", 1);
    }

    if( $bzip2 eq 'on' ) {
        __system ("tar cjPf $tarbase.tar.bz2 -C $distdir `ls $distdir`", 1);
    }

    __system("du -ab $tardir | sort -n");
}

sub resolve_dirs {
    my ($xml, $src_base, $dst_base) = @_;

    # get specified dirs 
    my @srcdirs = @{$xml->{srcdirs}->{srcdir}};
    my %dstdirs;
    for my $dstname (keys %{$xml->{dstdirs}->{dstdir}}) {
        $dstdirs{$dstname} = $xml->{dstdirs}->{dstdir}->{$dstname}->{content};
    }

    die "dst bindir not defined in xml file" if not defined $dstdirs{bindir};
    die "dst libdir not defined in xml file" if not defined $dstdirs{libdir};
    die "dst plugindir not defined in xml file" if not defined $dstdirs{plugindir};

    #make paths absolute
    for my $dir (@srcdirs) { $dir = fast_abs_path($src_base . "/" . $dir); $dir = $dir . "/"; };
    for my $name (keys %dstdirs) {
        my $absdstdir = $dst_base . "/" . $dstdirs{$name};
        mkpath $absdstdir;
        $dstdirs{$name} = fast_abs_path( $absdstdir ) . "/"; 
    };


    my %dirs;
    $dirs{srcdirs} = \@srcdirs;
    $dirs{dstdirs} = \%dstdirs;

    for my $dir (@{$dirs{srcdirs}}) { print "srcdir: $dir\n"; };
    for my $name (keys %dstdirs) { print "$name: $dstdirs{$name}\n"; }; 

    return %dirs;
}
sub main {
    my $xmlparsfile = '';
    my $src_base = '';
    my $dst_base = '';
    GetOptions('pars=s' => \$xmlparsfile, 
        'src_base=s' => \$src_base, 
        'dst_base=s' => \$dst_base,
        'dist_type=s' => \$dist_type );

    if( $xmlparsfile eq '' or $src_base eq '' or $dst_base eq '' ) {
        help(); 
        exit();
    }

    die "couldn't find $xmlparsfile." if not -e $xmlparsfile;

    check_prerequisites();

    my $xmlparser = XML::Simple->new(ForceArray => ['item', 'srcdir','dgroup','dstdir','tardist']);
    my $xml = $xmlparser->XMLin($xmlparsfile);
    #print Dumper( $xml ) and die;
    
    mkpath $dst_base;
    $src_base = fast_abs_path($src_base);
    $dst_base = fast_abs_path($dst_base);
    $xmlparsfile = fast_abs_path($xmlparsfile);

    if( defined $xml->{options}->{cleanfirst} ) { __system("rm -rf $dst_base/*", 1); };

    my $distdir = $dst_base."/dist";

    print "Building $dist_type distro.\n";
    print "src_base: $src_base\n";
    print "dst_base: $dst_base\n";
    print "parsfile: $xmlparsfile\n";

    my %dirs = resolve_dirs($xml, $src_base, $distdir);


    #deploy groups
    for my $group  (@{$xml->{deploy}->{dgroup}}) {
        deploy_group($group, $xml, \%dirs); 
    }

    create_tar_dist( $xml, $distdir, $dst_base."/tardist" ); 

}

main();
